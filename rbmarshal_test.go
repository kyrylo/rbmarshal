package rbmarshal

import (
	"bufio"
	"bytes"
	"errors"
	"math"
	"reflect"
	"regexp"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestLoad(t *testing.T) {
	cases := []struct {
		desc   string
		stream []byte
		err    error
		data   interface{}
	}{
		{
			"Correct stream version",
			[]byte{0x04, 0x08, 0x30},
			nil,
			nil,
		},
		{
			"Unsupported major version",
			[]byte{0x01, 0x08, 0x30},
			errors.New("unsupported marshal version [1 8], wanted [4 8]"),
			nil,
		},
		{
			"Unsupported minor version",
			[]byte{0x04, 0x01, 0x30},
			errors.New("unsupported marshal version [4 1], wanted [4 8]"),
			nil,
		},
		{
			"True",
			[]byte{0x04, 0x08, 0x54},
			nil,
			true,
		},
		{
			"False",
			[]byte{0x04, 0x08, 0x46},
			nil,
			false,
		},
		{
			"Fixnum 0",
			[]byte{0x04, 0x08, 0x69, 0x00},
			nil,
			0,
		},
		{
			"Fixnum 122",
			[]byte{0x04, 0x08, 0x69, 0x7F},
			nil,
			122,
		},
		{
			"Fixnum -122",
			[]byte{0x04, 0x08, 0x69, 0x81},
			nil,
			-122,
		},
		{
			"Fixnum 123",
			[]byte{0x04, 0x08, 0x69, 0x01, 0x7B},
			nil,
			123,
		},
		{
			"Fixnum -123",
			[]byte{0x04, 0x08, 0x69, 0x80},
			nil,
			-123,
		},
		{
			"Fixnum 124",
			[]byte{0x04, 0x08, 0x69, 0x01, 0x7C},
			nil,
			124,
		},
		{
			"Fixnum -124",
			[]byte{0x04, 0x08, 0x69, 0xFF, 0x84},
			nil,
			-124,
		},
		{
			"Fixnum 125",
			[]byte{0x04, 0x08, 0x69, 0x01, 0x7D},
			nil,
			125,
		},
		{
			"Fixnum -125",
			[]byte{0x04, 0x08, 0x69, 0xFF, 0x83},
			nil,
			-125,
		},
		{
			"Fixnum 200",
			[]byte{0x04, 0x08, 0x69, 0x01, 0xC8},
			nil,
			200,
		},
		{
			"Fixnum -200",
			[]byte{0x04, 0x08, 0x69, 0xFF, 0x38},
			nil,
			-200,
		},
		{
			"Fixnum 255",
			[]byte{0x04, 0x08, 0x69, 0x01, 0xFF},
			nil,
			255,
		},
		{
			"Fixnum -255",
			[]byte{0x04, 0x08, 0x69, 0xFF, 0x01},
			nil,
			-255,
		},
		{
			"Fixnum 256",
			[]byte{0x04, 0x08, 0x69, 0x02, 0x00, 0x01},
			nil,
			256,
		},
		{
			"Fixnum -256",
			[]byte{0x04, 0x08, 0x69, 0xFF, 0x00},
			nil,
			-256,
		},
		{
			"Fixnum 257",
			[]byte{0x04, 0x08, 0x69, 0x02, 0x01, 0x01},
			nil,
			257,
		},
		{
			"Fixnum -257",
			[]byte{0x04, 0x08, 0x69, 0xFE, 0xFF, 0xFE},
			nil,
			-257,
		},
		{
			"Fixnum 33333",
			[]byte{0x04, 0x08, 0x69, 0x02, 0x35, 0x82},
			nil,
			33333,
		},
		{
			"Fixnum -33333",
			[]byte{0x04, 0x08, 0x69, 0xFE, 0xCB, 0x7D},
			nil,
			-33333,
		},
		{
			"Fixnum 65535",
			[]byte{0x04, 0x08, 0x69, 0x02, 0xFF, 0xFF},
			nil,
			65535,
		},
		{
			"Fixnum -65535",
			[]byte{0x04, 0x08, 0x69, 0xFE, 0x01, 0x00},
			nil,
			-65535,
		},
		{
			"Fixnum 65536",
			[]byte{0x04, 0x08, 0x69, 0x03, 0x00, 0x00, 0x01},
			nil,
			65536,
		},
		{
			"Fixnum -65536",
			[]byte{0x04, 0x08, 0x69, 0xFE, 0x00, 0x00},
			nil,
			-65536,
		},
		{
			"Fixnum 65537",
			[]byte{0x04, 0x08, 0x69, 0x03, 0x01, 0x00, 0x01},
			nil,
			65537,
		},
		{
			"Fixnum -65537",
			[]byte{0x04, 0x08, 0x69, 0xFD, 0xFF, 0xFF, 0xFE},
			nil,
			-65537,
		},
		{
			"Bignum 1073741824",
			[]byte{0x04, 0x08, 0x6C, 0x2B, 0x07, 0x00, 0x00, 0x00, 0x40},
			nil,
			1073741824,
		},
		{
			"Bignum -1073741824",
			[]byte{0x04, 0x08, 0x69, 0xFC, 0x00, 0x00, 0x00, 0xC0},
			nil,
			-1073741824,
		},
		{
			"Bignum 1073741825",
			[]byte{0x04, 0x08, 0x6C, 0x2B, 0x07, 0x01, 0x00, 0x00, 0x40},
			nil,
			1073741825,
		},
		{
			"Bignum -1073741825",
			[]byte{0x04, 0x08, 0x6C, 0x2D, 0x07, 0x01, 0x00, 0x00, 0x40},
			nil,
			-1073741825,
		},
		{
			"Bignum 99999991073741825",
			[]byte{
				0x04, 0x08, 0x6C, 0x2B, 0x09, 0x01, 0x1C, 0x7E,
				0x49, 0x76, 0x45, 0x63, 0x01,
			},
			nil,
			99999991073741825,
		},
		{
			"Bignum -99999991073741825",
			[]byte{
				0x04, 0x08, 0x6C, 0x2D, 0x09, 0x01, 0x1C, 0x7E,
				0x49, 0x76, 0x45, 0x63, 0x01,
			},
			nil,
			-99999991073741825,
		},
		{
			"String '' (empty)",
			[]byte{
				0x04, 0x08, 0x49, 0x22, 0x00, 0x06, 0x3A, 0x06,
				0x45, 0x54,
			},
			nil,
			"",
		},
		{
			"String 'Hi'",
			[]byte{
				0x04, 0x08, 0x49, 0x22, 0x07, 0x48, 0x69, 0x06,
				0x3A, 0x06, 0x45, 0x54,
			},
			nil,
			"Hi",
		},
		{
			"String 'Hi' in ASCII_8BIT",
			[]byte{0x04, 0x08, 0x22, 0x07, 0x48, 0x69},
			nil,
			"Hi",
		},
		{
			"String 'Hello! World?'",
			[]byte{
				0x04, 0x08, 0x49, 0x22, 0x12, 0x48, 0x65, 0x6C,
				0x6C, 0x6F, 0x21, 0x20, 0x57, 0x6F, 0x72, 0x6C,
				0x64, 0x3F, 0x06, 0x3A, 0x06, 0x45, 0x54,
			},
			nil,
			"Hello! World?",
		},
		{
			"String 'Привет, мир!'",
			[]byte{
				0x04, 0x08, 0x49, 0x22, 0x1A, 0xD0, 0x9F, 0xD1,
				0x80, 0xD0, 0xB8, 0xD0, 0xB2, 0xD0, 0xB5, 0xD1,
				0x82, 0x2C, 0x20, 0xD0, 0xBC, 0xD0, 0xB8, 0xD1,
				0x80, 0x21, 0x06, 0x3A, 0x06, 0x45, 0x54,
			},
			nil,
			"Привет, мир!",
		},
		{
			"Empty array",
			[]byte{0x04, 0x08, 0x5b, 0x00},
			nil,
			make([]interface{}, 0),
		},
		{
			"Array of integers",
			[]byte{
				0x04, 0x08, 0x5b, 0x08, 0x69, 0x06, 0x69, 0x07,
				0x69, 0x8,
			},
			nil,
			makeSlice(1, 2, 3),
		},
		{
			"Array of bignums",
			[]byte{
				0x04, 0x08, 0x5b, 0x08, 0x69, 0x02, 0xe8, 0x03,
				0x69, 0x02, 0xd0, 0x07, 0x69, 0x04, 0x80, 0xc3,
				0xc9, 0x01,
			},
			nil,
			makeSlice(1000, 2000, 30000000),
		},
		{
			"Array of nil, false, true",
			[]byte{0x04, 0x08, 0x5b, 0x08, 0x30, 0x46, 0x54},
			nil,
			makeSlice(nil, false, true),
		},
		{
			"Array of string",
			[]byte{
				0x04, 0x08, 0x5b, 0x08, 0x49, 0x22, 0x08, 0x6f,
				0x6e, 0x65, 0x06, 0x3a, 0x06, 0x45, 0x54, 0x49,
				0x22, 0x08, 0x74, 0x77, 0x6f, 0x06, 0x3b, 0x00,
				0x54, 0x49, 0x22, 0x0c, 0x47, 0x4f, 0x4c, 0x41,
				0x4e, 0x47, 0x21, 0x06, 0x3b, 0x00, 0x54,
			},
			nil,
			makeSlice("one", "two", "GOLANG!"),
		},
		{
			"Array of mixed objects",
			[]byte{
				0x04, 0x08, 0x5b, 0x09, 0x69, 0x06, 0x49, 0x22,
				0x08, 0x6f, 0x6e, 0x65, 0x06, 0x3a, 0x06, 0x45,
				0x54, 0x69, 0x04, 0x15, 0xcd, 0x5b, 0x07, 0x46,
			},
			nil,
			makeSlice(1, "one", 123456789, false),
		},
		{
			"Array nested",
			[]byte{
				0x04, 0x08, 0x5b, 0x06, 0x5b, 0x08, 0x5b, 0x07,
				0x69, 0x06, 0x69, 0x09, 0x5b, 0x07, 0x69, 0x07,
				0x69, 0x0a, 0x5b, 0x07, 0x69, 0x08, 0x69, 0x0b,
			},
			nil,

			// [[[1, 4], [2, 5], [3, 6]]]
			makeSlice(
				makeSlice(
					makeSlice(1, 4),
					makeSlice(2, 5),
					makeSlice(3, 6),
				),
			),
		},
		{
			"Array nested empty",
			[]byte{
				0x04, 0x08, 0x5b, 0x06, 0x5b, 0x08, 0x5b, 0x00,
				0x5b, 0x00, 0x5b, 0x06, 0x5b, 0x00,
			},
			nil,

			// [[[], [], [[]]]]
			makeSlice(
				makeSlice(
					makeSlice(),
					makeSlice(),
					makeSlice(makeSlice()),
				),
			),
		},
		{
			"Array nested empty and nonempty",
			[]byte{
				0x04, 0x08, 0x5b, 0x06, 0x5b, 0x08, 0x5b, 0x00,
				0x5b, 0x07, 0x69, 0x06, 0x69, 0x07, 0x5b, 0x06,
				0x5b, 0x00,
			},
			nil,

			// [[[], [1, 2], [[]]]]
			makeSlice(
				makeSlice(
					makeSlice(),
					makeSlice(1, 2),
					makeSlice(makeSlice()),
				),
			),
		},
		{
			"Array with regexps",
			[]byte{
				0x04, 0x08, 0x5b, 0x09, 0x49, 0x2f, 0x00, 0x00,
				0x06, 0x3a, 0x06, 0x45, 0x46, 0x49, 0x2f, 0x00,
				0x00, 0x06, 0x3b, 0x00, 0x46, 0x49, 0x22, 0x00,
				0x06, 0x3b, 0x00, 0x54, 0x69, 0x06,
			},
			nil,

			// [//, //, "", 1]
			makeSlice(
				regexp.MustCompile(""),
				regexp.MustCompile(""),
				"",
				1,
			),
		},
		{
			"Positive float number",
			[]byte{0x04, 0x08, 0x66, 0x09, 0x33, 0x2e, 0x31, 0x34},
			nil,
			3.14,
		},
		{
			"Negative float number",
			[]byte{0x04, 0x08, 0x66, 0x0a, 0x2d, 0x33, 0x2e, 0x31, 0x34},
			nil,
			-3.14,
		},
		{
			"Positive float infinity",
			[]byte{0x04, 0x08, 0x66, 0x08, 0x69, 0x6e, 0x66},
			nil,
			math.Inf(1),
		},
		{
			"Negative float infinity",
			[]byte{0x04, 0x08, 0x66, 0x09, 0x2d, 0x69, 0x6e, 0x66},
			nil,
			math.Inf(-1),
		},
		{
			"Float with mantissa",
			[]byte{
				0x04, 0x08, 0x66, 0x17, 0x31, 0x30, 0x2e, 0x39,
				0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
				0x39, 0x39, 0x39, 0x39, 0x39, 0x38,
			},
			nil,
			10.999999999999999,
		},
		{
			"Empty regexp",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x00, 0x00, 0x06, 0x3a,
				0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile(""),
		},
		{
			"Non-empty regexp",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x12, 0x5c, 0x41, 0x5b,
				0x30, 0x2d, 0x39, 0x5d, 0x2b, 0x5c, 0x2e, 0x2e,
				0x2a, 0x24, 0x00, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile(`\A[0-9]+\..*$`),
		},
		{
			"Regexp with the 'o' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x00, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("[a-z]"),
		},
		{
			"Regexp with the 'i' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x01, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("(?i)[a-z]"),
		},
		{
			"Regexp with the 'x' option (unsupported by Go)",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x02, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("[a-z]"),
		},
		{
			"Regexp with the 'ix' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x03, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("(?i)[a-z]"),
		},
		{
			"Regexp with the 'm' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x04, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("(?s)[a-z]"),
		},
		{
			"Regexp with the 'im' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x05, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("(?is)[a-z]"),
		},
		{
			"Regexp with the 'xm' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x06, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("(?s)[a-z]"),
		},
		{
			"Regexp with the 'xmi' option",
			[]byte{
				0x04, 0x08, 0x49, 0x2f, 0x0a, 0x5b, 0x61, 0x2d,
				0x7a, 0x5d, 0x07, 0x06, 0x3a, 0x06, 0x45, 0x46,
			},
			nil,
			regexp.MustCompile("(?is)[a-z]"),
		},
		{
			"Symbol 'hello'",
			[]byte{
				0x04, 0x08, 0x3a, 0x0a, 0x68, 0x65, 0x6c, 0x6c,
				0x6f,
			},
			nil,
			"hello",
		},
		{
			"Symbol with symlinks",
			[]byte{
				0x04, 0x08, 0x5b, 0x0b, 0x3a, 0x06, 0x61, 0x3b,
				0x00, 0x3a, 0x06, 0x62, 0x3a, 0x06, 0x63, 0x3b,
				0x07, 0x3b, 0x06,
			},
			nil,
			makeSlice("a", "a", "b", "c", "c", "b"),
		},
		{
			"Empty hash",
			[]byte{0x04, 0x08, 0x7b, 0x00},
			nil,
			map[string]interface{}{},
		},
		{
			"Simple hash",
			[]byte{
				0x04, 0x08, 0x7b, 0x07, 0x3a, 0x0b, 0x73, 0x69,
				0x6d, 0x70, 0x6c, 0x65, 0x69, 0x06, 0x3a, 0x09,
				0x68, 0x61, 0x73, 0x68, 0x69, 0x07,
			},
			nil,
			map[string]interface{}{
				"simple": 1,
				"hash":   2,
			},
		},
		{
			"Nested hash",
			[]byte{
				0x04, 0x08, 0x7b, 0x08, 0x3a, 0x0b, 0x73, 0x69,
				0x6d, 0x70, 0x6c, 0x65, 0x69, 0x06, 0x3a, 0x0b,
				0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x7b, 0x06,
				0x3a, 0x09, 0x68, 0x61, 0x73, 0x68, 0x69, 0x07,
				0x3a, 0x07, 0x68, 0x69, 0x69, 0x08,
			},
			nil,
			map[string]interface{}{
				"simple": 1,
				"nested": map[string]interface{}{
					"hash": 2,
				},
				"hi": 3,
			},
		},
		{
			"Empty hash of hashes",
			[]byte{0x04, 0x08, 0x7b, 0x06, 0x7b, 0x00, 0x7b, 0x00},
			nil,
			map[string]interface{}{
				"": map[string]interface{}{},
			},
		},
		{
			"Hash with numeric keys",
			[]byte{
				0x04, 0x08, 0x7b, 0x07, 0x69, 0x06, 0x69, 0x07,
				0x69, 0x08, 0x69, 0x09,
			},
			nil,
			map[string]interface{}{
				"1": 2,
				"3": 4,
			},
		},
		{
			"Complex hash with mixed values",
			[]byte{
				0x04, 0x08, 0x7b, 0x09, 0x3a, 0x08, 0x66, 0x6f,
				0x6f, 0x69, 0x06, 0x3a, 0x08, 0x62, 0x61, 0x72,
				0x49, 0x22, 0x08, 0x62, 0x61, 0x7a, 0x06, 0x3a,
				0x06, 0x45, 0x54, 0x3a, 0x0a, 0x61, 0x72, 0x72,
				0x61, 0x79, 0x5b, 0x08, 0x69, 0x06, 0x69, 0x07,
				0x49, 0x2f, 0x00, 0x00, 0x06, 0x3b, 0x07, 0x46,
				0x3a, 0x09, 0x68, 0x61, 0x73, 0x68, 0x7b, 0x08,
				0x3a, 0x0a, 0x62, 0x69, 0x6e, 0x67, 0x6f, 0x66,
				0x08, 0x31, 0x2e, 0x32, 0x3a, 0x0a, 0x62, 0x61,
				0x6e, 0x67, 0x6f, 0x66, 0x08, 0x33, 0x2e, 0x34,
				0x3a, 0x0a, 0x62, 0x6f, 0x6e, 0x67, 0x6f, 0x5b,
				0x06, 0x49, 0x22, 0x07, 0x68, 0x69, 0x06, 0x3b,
				0x07, 0x54,
			},
			nil,
			map[string]interface{}{
				// {foo: 1, bar: "baz", array: [1, 2, //], hash: { bingo: 1.2, bango: 3.4, bongo: ["hi"] }}
				"foo":   1,
				"bar":   "baz",
				"array": makeSlice(1, 2, regexp.MustCompile("")),
				"hash": map[string]interface{}{
					"bingo": 1.2,
					"bango": 3.4,
					"bongo": makeSlice("hi"),
				},
			},
		},
		{
			"Hash with the same key and value",
			[]byte{
				0x04, 0x08, 0x7b, 0x06, 0x3a, 0x06, 0x61, 0x3a,
				0x06, 0x62,
			},
			nil,
			map[string]interface{}{"a": "b"},
		},
	}

	for _, c := range cases {
		t.Run(c.desc, func(t *testing.T) {
			r := bytes.NewReader(c.stream)
			buf := bufio.NewReader(r)

			data, err := Load(buf)
			if c.err == nil && err != nil {
				t.Fatalf("unexpected error: '%q'", err)
				return
			}
			if c.err != nil && err != nil {
				if c.err.Error() != err.Error() {
					t.Fatalf("expected error %q, want %q", err, c.err)
				}
				return
			}
			if c.err != nil && err == nil {
				t.Errorf("expected error %q, got nothing", c.err)
			}

			switch v := data.(type) {
			case []interface{}:
				d, ok := c.data.([]interface{})
				if !ok {
					t.Errorf("c.data: error asserting the type of %d", d)
					return
				}
				if !cmp.Equal(v, d, cmp.Comparer(equalRegexps)) {
					t.Errorf("data: got %d, want %d", v, c.data)
				}
			case *regexp.Regexp:
				if !equalRegexps(v, c.data.(*regexp.Regexp)) {
					t.Errorf("data: got %s, want %s", v, c.data)
				}
			case map[string]interface{}:
				if !reflect.DeepEqual(v, c.data) {
					t.Errorf("data: got %s, want %s", v, c.data)
				}
			default:
				if v != c.data {
					t.Errorf("data: got %d, want %d", v, c.data)
				}
			}
		})
	}
}

func makeSlice(args ...interface{}) []interface{} {
	s := make([]interface{}, len(args))
	for i, arg := range args {
		s[i] = arg
	}

	return s
}

func equalRegexps(x, y *regexp.Regexp) bool {
	return x.String() == y.String()
}
